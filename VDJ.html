<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>V(D)J Recombination â€” Phaser Starter</title>
  <style>
    html,body { height:100%; width:100%; margin:0; background:#0f172a; overflow:hidden; }
    #game-container { 
      width:100%; 
      height:100%; 
      display: block;
      visibility: visible;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
  <!-- Fallback if first CDN fails -->
  <script>
    if (typeof Phaser === 'undefined') {
      console.error('Primary Phaser load failed, trying backup...');
      document.write('<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"><\/script>');
    }
  </script>
</head>
<body>
  <div id="game-container"></div>
<script>
class GameScene extends Phaser.Scene {
  constructor() { 
    super('GameScene');
    console.log('GameScene constructor called');
  }

  preload() {
    console.log('Preload started');
    // Load background music (first available music file in the music/ folder)
    try {
      this.load.audio('bgm', 'music/8-bit-arcade-138828.mp3');
    } catch (e) {
      console.warn('Failed to queue bgm file for loading', e);
    }
  }

  create() {
    console.log('Create method started');
    const width = this.scale.width;
    const height = this.scale.height;

  // Theme / sizing constants (centralized)
  this.PALETTE = { V: 0x8b5cf6, D: 0xfb923c, J: 0x34d399, neutralStroke: 0x17375f, tileTextColor: '#ffffff', tileEdgeColor: 0x051124 };
  this.boxRadiusFactor = 0.08; // relative rounding
  this.boxTextScaleFactor = 0.18; // text size relative to boxSize

    this.score = 0;

    this.scoreText = this.add.text(18, height-54, 'Score: 0', { fontSize:'18px', color:'#e6eef8' }).setDepth(10);
    this.feedback = this.add.text(18, height-28, '', { fontSize:'14px', color:'#a7f3d0' }).setDepth(10);

    const poolY = height - 160;
    // bottom pool background (no blue outline) - we'll draw DNA-like strands over it
    const poolW = width - 40;
    const poolH = 120;
    const poolX = 20;
    const poolYTop = poolY + 40 - poolH/2;
    const poolBg = this.add.graphics();
    poolBg.fillStyle(0x071127, 0.9);
    const poolRadius = 8;
    poolBg.fillRoundedRect(poolX, poolYTop, poolW, poolH, poolRadius);

    // DNA graphics: animated wavy strands behind the belts but above the background
    this.dnaGraphics = this.add.graphics().setDepth(0);
    this.dnaPhase = 0;
    // draw initial DNA
    this.drawDNA = (phase) => {
      const g = this.dnaGraphics;
      g.clear();
      const w = this.scale.width;
      const midY = poolY + 40; // central Y for DNA waves
      const ampBase = 10;
      const wavelength = Math.max(120, Math.floor(w / 8));
      // strand colors (subtle, not bright blue)
      const strandA = 0x86efac; // light green
      const strandB = 0xf0abfc; // light purple

      const drawWave = (offsetPhase, color, thickness, invert) => {
        g.lineStyle(thickness, color, 0.9);
        g.beginPath();
        for (let x = 0; x <= w; x += 6) {
          const px = x;
          const t = (x / wavelength) * Math.PI * 2 + offsetPhase;
          const amp = ampBase + Math.sin(phase * 1.2 + x * 0.02) * 6;
          const y = midY + (invert ? -1 : 1) * Math.sin(t) * amp;
          if (x === 0) g.moveTo(px, y);
          else g.lineTo(px, y);
        }
        g.strokePath();
      };

      drawWave(phase * 0.9, strandA, 3, false);
      drawWave(phase * 0.9 + Math.PI, strandB, 3, true);
    };
  // removed pool label per UI update

  // Drag-drop removed: no drop slots needed

  // Expanded pools so there are many more segments available
  this.vPool = ['V1','V2','V3','V4','V5','V6','V7','V8','V9','V10'];
  this.dPool = ['D1','D2','D3','D4','D5','D6'];
  this.jPool = ['J1','J2','J3','J4','J5','J6','J7','J8'];

  // prepare poolSprites as a flat array for static puzzle
  this.poolSprites = [];

  this.makeRound();

    // --- Game mode: pathogens and recipes ---
    // Do not display recipe list in UI (only show current target in top-right)
    // Available sprite files (embedded from workspace). Add more files to Sprites/ and refresh Live Server.
    const availableSpriteFiles = [
      'covid.PNG',
      'flaggelated.PNG',
      'Fungus.PNG',
      'hiv.PNG',
      'influenza_a.jpeg',
      'phage.PNG',
      'Pilli.PNG',
      'pollen.PNG',
      'rod.PNG',
      'Rota.PNG',
      'wormmm.PNG'
    ];

    // Use the filenames (without extension) from Sprites/ as pathogen display names, preserving case
    const defaultNames = ['Influenza A','SARS-CoV-2','HIV','Ebola','Tuberculosis','Streptococcus','Salmonella','Malaria','Zika','Norovirus'];
    const filenameBases = availableSpriteFiles.map(f => f.replace(/\.[^.]+$/, ''));
    const pathogenNames = [];
    for (let i=0;i<filenameBases.length && pathogenNames.length<10;i++) pathogenNames.push(filenameBases[i]);
    let di = 0;
    while (pathogenNames.length < 10 && di < defaultNames.length) {
      if (!pathogenNames.includes(defaultNames[di])) pathogenNames.push(defaultNames[di]);
      di++;
    }

    // assign recipes using shuffled V/D/J pools
    this.pathogens = [];
    const sv = Phaser.Utils.Array.Shuffle(this.vPool.slice());
    const sd = Phaser.Utils.Array.Shuffle(this.dPool.slice());
    const sj = Phaser.Utils.Array.Shuffle(this.jPool.slice());
    for (let i = 0; i < 10; i++) {
      const v = sv[i % sv.length];
      const d = sd[i % sd.length];
      const j = sj[i % sj.length];
      const name = pathogenNames[i] || defaultNames[i % defaultNames.length];
      this.pathogens.push({ name, recipe: `${v}-${d}-${j}`, done: false });
    }

    // Queue image loads by mapping available files to pathogens in order (if present)
    this.pathogenImageKeys = [];
    for (let i = 0; i < this.pathogens.length; i++) {
      if (i < availableSpriteFiles.length) {
        const f = availableSpriteFiles[i];
        const key = 'pathogen_' + i + '_file';
        this.load.image(key, 'Sprites/' + f);
        this.pathogenImageKeys[i] = { key };
      } else {
        this.pathogenImageKeys[i] = { key: null };
      }
    }
    // start the loader and refresh target UI when complete
    this.load.once('complete', () => {
      this.imagesLoaded = true;
      try {
        // Debug: list loaded texture keys
        const keys = Object.keys(this.textures.list || {});
        console.log('Image loader complete. Loaded texture keys:', keys);
      } catch (e) { console.warn('Could not list textures after load complete', e); }
      this.updateCurrentTarget();
    });
    this.load.start();

    // Timer (top-left, large, show only number)
    this.timeLeft = 60; // default 60 seconds
    this.timerText = this.add.text(18, 18, `${this.timeLeft}`, { fontSize: '48px', color: '#e6eef8', fontStyle: 'bold' }).setOrigin(0, 0).setDepth(10);
    this.timerEvent = this.time.addEvent({ delay: 1000, loop: true, callback: () => {
      this.timeLeft -= 1;
      this.timerText.setText(`${this.timeLeft}`);
      if (this.timeLeft <= 0) {
        this.endGame(false);
      }
    }});

    // Top-center: recipe boxes (three) to show the target V-D-J
    this.topRecipeBoxes = [];
    const topY = 32;
    const topBoxW = 110;
    const topGap = 18;
    const topTotalWidth = 3 * topBoxW + 2 * topGap;
    const topStartX = Math.round((width - topTotalWidth) / 2) + topBoxW/2;
    for (let i=0;i<3;i++) {
      const x = topStartX + i * (topBoxW + topGap);
      const r = this.add.rectangle(x, topY, topBoxW, 56, 0x0b1220).setStrokeStyle(2, this.PALETTE.neutralStroke).setAlpha(0.95).setDepth(13);
      const t = this.add.text(x, topY, '', { fontSize:'18px', color:'#e6eef8', align:'center' }).setOrigin(0.5).setDepth(13);
      this.topRecipeBoxes.push({ rect: r, text: t });
    }

    // Top-right: current target pathogen image (next to boxes)
    const targetBoxW = 140;
    const targetBoxH = 140;
    const targetX = topStartX + topTotalWidth/2 + topGap + targetBoxW/2; // right of the boxes
    const targetY = topY;
    this.targetContainer = this.add.container(targetX, targetY).setDepth(12).setSize(targetBoxW, targetBoxH);
    this.targetGraphic = this.add.graphics().setDepth(13);
    this.targetContainer.add(this.targetGraphic);
    this.targetImage = null;

    // Track current target and initialize UI
    this.currentTargetIndex = -1;
    this.updateCurrentTarget();

    // Drag events removed

  // Next button removed per user request
  }

  makeRound() {
    // Destroy existing sprites
    if (this.poolSprites && Array.isArray(this.poolSprites)) {
      this.poolSprites.forEach(s => { try { s.destroy(); } catch(e) {} });
      this.poolSprites = [];
    }

    // Choose exactly 5 of each V, D, J for a static puzzle row
  // Choose exactly 5 of each V, D, J for a static puzzle row
  // Keep groups in order: all V first, then D, then J
  const availableV = Phaser.Utils.Array.Shuffle(this.vPool).slice(0,5);
  const availableD = Phaser.Utils.Array.Shuffle(this.dPool).slice(0,5);
  const availableJ = Phaser.Utils.Array.Shuffle(this.jPool).slice(0,5);
  // Build grouped combined array (V block, then D block, then J block)
  let combined = [];
  availableV.forEach(name => combined.push({ name, type: 'V' }));
  availableD.forEach(name => combined.push({ name, type: 'D' }));
  availableJ.forEach(name => combined.push({ name, type: 'J' }));

  // Static row setup (centered vertically, smaller tiles so all are visible)
  const margin = 60;
  const boxSize = 100; // smaller tiles
  this.boxTextScaleFactor = 0.18;
  const puzzleY = Math.floor(this.scale.height / 2);
    // Layout pattern: VVVVV - D1 - JJJJJ - C1 - D2 - JJJJJ - C2
    const tileGap = 12;
    const groupGap = 36; // extra spacing between main groups
    const cWidth = 140; // width of constant C blocks
    // Prepare selections (use modulo wrap if pool smaller)
    const vCount = 5;
    const dCount = 2; // we will use two D singles
    const jBlock = 5; // number of J tiles per block

    // select V, D, J items (wrap if necessary)
    const selV = [];
    const selD = [];
    const selJ = [];
    for (let i=0;i<vCount;i++) selV.push(availableV[i % availableV.length]);
    for (let i=0;i<dCount;i++) selD.push(availableD[i % availableD.length]);
    // need two J blocks worth: total jCount = jBlock * 2
    for (let i=0;i<jBlock*2;i++) selJ.push(availableJ[i % availableJ.length]);

    // compute total width
    const vWidth = vCount * boxSize + Math.max(0, vCount - 1) * tileGap;
    const dWidth = dCount * boxSize + Math.max(0, dCount - 1) * tileGap;
    const jWidth = (jBlock * 2) * boxSize + Math.max(0, (jBlock * 2) - 1) * tileGap;
    const totalWidth = vWidth + dWidth + jWidth + groupGap * 2 + cWidth * 2;
    const availableWidth = Math.max(0, this.scale.width - 2 * margin);
    const startX = margin + Math.floor((availableWidth - totalWidth) / 2) + Math.floor(boxSize/2);

    // clear any existing constant graphics
    if (this.constantGraphics && Array.isArray(this.constantGraphics)) { this.constantGraphics.forEach(cg => { try { cg.destroy(); } catch(e){} }); }
    this.constantGraphics = [];

    // place groups sequentially
    let cursorX = startX;
    // V group
    for (let i = 0; i < vCount; i++) {
      const seg = { name: selV[i], type: 'V' };
      const x = cursorX;
      const y = puzzleY;
      const g = this.createTileContainer(seg, x, y, boxSize);
      g.setData('homeX', x);
      g.setData('homeY', y);
      this.poolSprites.push(g);
      cursorX += boxSize + tileGap;
    }
    // D1 (single)
    cursorX += groupGap - tileGap;
    const d1Seg = { name: selD[0], type: 'D' };
    let g = this.createTileContainer(d1Seg, cursorX, puzzleY, boxSize);
    g.setData('homeX', cursorX); g.setData('homeY', puzzleY); this.poolSprites.push(g);
    cursorX += boxSize + tileGap;
    // J block 1
    cursorX += groupGap - tileGap;
    for (let i=0;i<jBlock;i++) {
      const seg = { name: selJ[i], type: 'J' };
      const x = cursorX;
      const y = puzzleY;
      const gj = this.createTileContainer(seg, x, y, boxSize);
      gj.setData('homeX', x); gj.setData('homeY', y); this.poolSprites.push(gj);
      cursorX += boxSize + tileGap;
    }
    // C1 constant block (non-interactive)
    const c1x = cursorX + cWidth/2;
    const c1 = this.add.graphics();
    c1.fillStyle(0xfff382, 1);
    const cRadius = 8;
    c1.fillRoundedRect(c1x - cWidth/2, puzzleY - boxSize/2, cWidth, boxSize, cRadius);
    const c1Text = this.add.text(c1x, puzzleY, 'C1', { fontSize: '18px', color: '#000000', fontStyle: 'bold' }).setOrigin(0.5);
    this.constantGraphics.push(c1, c1Text);
    cursorX += cWidth + tileGap;
    // D2 single
    const d2Seg = { name: selD[1 % selD.length], type: 'D' };
    const g2 = this.createTileContainer(d2Seg, cursorX, puzzleY, boxSize);
    g2.setData('homeX', cursorX); g2.setData('homeY', puzzleY); this.poolSprites.push(g2);
    cursorX += boxSize + tileGap;
    // J block 2
    cursorX += groupGap - tileGap;
    for (let i=0;i<jBlock;i++) {
      const seg = { name: selJ[jBlock + i], type: 'J' };
      const x = cursorX;
      const y = puzzleY;
      const gj = this.createTileContainer(seg, x, y, boxSize);
      gj.setData('homeX', x); gj.setData('homeY', y); this.poolSprites.push(gj);
      cursorX += boxSize + tileGap;
    }
    // C2 constant block
    const c2x = cursorX + cWidth/2;
    const c2 = this.add.graphics();
    c2.fillStyle(0xfff382, 1);
    c2.fillRoundedRect(c2x - cWidth/2, puzzleY - boxSize/2, cWidth, boxSize, cRadius);
    const c2Text = this.add.text(c2x, puzzleY, 'C2', { fontSize: '18px', color: '#000000', fontStyle: 'bold' }).setOrigin(0.5);
    this.constantGraphics.push(c2, c2Text);
    cursorX += cWidth + tileGap;

    // Reset drop slots and ensure their outlines are neutral
    this.dropSlots.forEach(s => { if (s.occupied) { s.occupied.destroy(); s.occupied = null; } });
    this.resetAllSlotOutlines();
    this.feedback.setText('Select a V, D and J from the row and place them into the slots.');
  }

  returnToPool(gameObject) {
    this.tweens.add({ targets: gameObject, x: gameObject.getData('homeX'), y: gameObject.getData('homeY'), scale:1, duration: 300, ease:'Cubic' });
  }

  update(time, delta) {
    // animate DNA strands behind the belts
    if (this.dnaGraphics && typeof this.dnaPhase === 'number') {
      this.dnaPhase += (delta / 1000) * 1.2; // speed factor
      if (this.dnaPhase > Math.PI * 4) this.dnaPhase = 0;
      this.drawDNA(this.dnaPhase);
    }
    // Static puzzle: no conveyor movement. Ensure home positions are up-to-date for return animations
    if (this.poolSprites && Array.isArray(this.poolSprites)) {
      this.poolSprites.forEach(g => { if (g && !g.getData('placed')) { g.setData('homeX', g.x); g.setData('homeY', g.y); } });
    }
  }

  checkComplete() {
    if (this.dropSlots.every(s => s.occupied)) {
      const assembled = this.dropSlots.map(s => s.occupied.getData('name')).join('-');
      // Check if assembled combination matches any pathogen recipe that is not yet done
      const match = this.pathogens && this.pathogens.find(p => !p.done && p.recipe === assembled);
      if (match) {
        match.done = true;
        const idx = this.pathogens.indexOf(match);
        if (this.recipeTexts && this.recipeTexts[idx]) {
          this.recipeTexts[idx].setColor('#10b981'); // green when completed
          this.recipeTexts[idx].setText(`${match.name}: ${match.recipe} (neutralized)`);
        }
        this.feedback.setText('Neutralized: ' + match.name + ' â€” Good job! (+100)');
        this.score += 100;
        this.timeLeft += 8; // small time bonus
        // update the top-right target (advance to next incomplete)
        this.updateCurrentTarget && this.updateCurrentTarget();
      } else {
        // Incorrect assembly: show fail animation and discard the three tiles
        this.feedback.setText('Incorrect combination â€” discarded');
  // collect occupied tiles
  const occupiedTiles = this.dropSlots.map(s => s.occupied).filter(Boolean);
  // remove them from their belt arrays so conveyor doesn't try to move destroyed objects
  occupiedTiles.forEach(t => { this.removeFromPools(t); });
        // animate slot flash and destroy tiles
        this.dropSlots.forEach((s, si) => {
          if (s.rect) {
            this.tweens.add({ targets: s.rect, alpha: 1, duration: 120, yoyo: true });
          }
        });
        // tween tiles out and destroy
        occupiedTiles.forEach((t, i) => {
          t.input && (t.input.enabled = false);
          this.tweens.add({ targets: t, props: { scale: { value: 1.2, duration: 160, yoyo: true }, alpha: { value: 0, duration: 420, delay: 200 } }, onComplete: () => { try { t.destroy(); } catch (e) {} } });
        });
    // clear slot occupancy immediately so player can continue and reset outlines
    this.dropSlots.forEach(s => { s.occupied = null; });
    this.resetAllSlotOutlines();
      }
      // If match branch awarded points above, update score (only if score changed)
      this.updateScore();

      // Find currently occupied targets for animation
      const placedTargets = this.dropSlots.map(s => s.occupied).filter(Boolean);

      // If all pathogens neutralized -> win
      if (this.pathogens && this.pathogens.every(p => p.done)) {
        // show success animation then end
        if (placedTargets.length) {
          this.tweens.add({ targets: placedTargets, scale: { value:1.06, duration:140, yoyo:true, ease:'Sine' } });
        }
        this.endGame(true);
        return;
      }

      // If we matched a pathogen (match != null) then perform success animation, clear placed tiles and start new round
      if (match) {
        if (placedTargets.length) {
          this.tweens.add({ targets: placedTargets, scale: { value:1.06, duration:140, yoyo:true, ease:'Sine' } });
        }
        this.time.delayedCall(700, () => {
          // destroy only the placed tiles (they were consumed)
          this.dropSlots.forEach(s => { if (s.occupied) { try { s.occupied.destroy(); } catch(e) {} s.occupied = null; } });
          // rebuild round (refresh sprites): destroy all pool sprites
          if (this.poolSprites) {
            if (Array.isArray(this.poolSprites)) { this.poolSprites.forEach(s => { try { s.destroy(); } catch(e){} }); this.poolSprites = []; }
            else { ['V','D','J'].forEach(k => { if (this.poolSprites[k]) { this.poolSprites[k].forEach(s => { try { s.destroy(); } catch(e){} }); this.poolSprites[k] = []; } }); }
          }
          this.makeRound();
        });
      } else {
        // incorrect assembly case: we already animated and destroyed the occupied tiles above; nothing more to do here
      }
    }
  }

  updateScore() {
    this.scoreText.setText('Score: ' + this.score);
  }

  // Create a tile container (rounded rect + label), wired for drag and with sensible defaults
  createTileContainer(seg, x, y, boxSize) {
    const g = this.add.container(x, y);
    const color = this.PALETTE[seg.type] || this.PALETTE.J;
    const rectG = this.add.graphics();
    rectG.fillStyle(color, 1);
    const radius = Math.round(boxSize * this.boxRadiusFactor);
    rectG.fillRoundedRect(-boxSize/2, -boxSize/2, boxSize, boxSize, radius);
    rectG.lineStyle(2, this.PALETTE.tileEdgeColor, 1);
    rectG.strokeRoundedRect(-boxSize/2, -boxSize/2, boxSize, boxSize, radius);
    const text = this.add.text(0, 0, seg.name, {
      fontSize: Math.round(boxSize * this.boxTextScaleFactor) + 'px',
      color: this.PALETTE.tileTextColor,
      fontStyle: 'bold',
      align: 'center'
    }).setOrigin(0.5);
    text.setShadow(1, 1, '#000000', 0.6, false, true);
    g.add([rectG, text]);
    g.setSize(boxSize, boxSize);
    // store references for selection toggling
    g._rectG = rectG;
    g._label = text;
    g.setInteractive(new Phaser.Geom.Rectangle(-boxSize/2, -boxSize/2, boxSize, boxSize), Phaser.Geom.Rectangle.Contains);
    this.input.setDraggable(g);
    // selection state
    g.setData('selected', false);
    // toggle selection on pointerup only when not dragged
    g.on('pointerup', (pointer) => {
      try {
        if (!g.getData('dragging')) {
          this.toggleSelection(g);
        }
      } catch (e) { /* ignore */ }
    });
    g.setData('type', seg.type);
    g.setData('name', seg.name);
    g.setData('homeX', x);
    g.setData('homeY', y);
    g.setData('homeW', boxSize);
    g.setData('placed', false);
    g.setData('dragging', false);
    return g;
  }

  // Toggle selection visual for a tile (selected tiles will be removed when user clicks Remove)
  toggleSelection(gameObject) {
    if (!gameObject) return;
    const sel = !!gameObject.getData('selected');
    gameObject.setData('selected', !sel);
    try {
      const rectG = gameObject._rectG;
      if (!rectG) return;
      rectG.clear();
      const color = this.PALETTE[gameObject.getData('type')] || this.PALETTE.J;
      const boxSize = gameObject.width || (gameObject.getData('homeW') || 100);
      const radius = Math.round(boxSize * this.boxRadiusFactor);
      // fill
      rectG.fillStyle(color, 1);
      rectG.fillRoundedRect(-boxSize/2, -boxSize/2, boxSize, boxSize, radius);
      // thicker stroke when selected
      if (gameObject.getData('selected')) {
        rectG.lineStyle(4, 0xffffff, 1);
      } else {
        rectG.lineStyle(2, this.PALETTE.tileEdgeColor, 1);
      }
      rectG.strokeRoundedRect(-boxSize/2, -boxSize/2, boxSize, boxSize, radius);
    } catch (e) { console.warn('toggleSelection failed', e); }
  }

  // Reflow the static pool row to center remaining tiles and update their home positions
  rearrangePool() {
    try {
      const margin = 60;
      const boxSize = 100;
      const tileGap = 12;
      const groupGap = 36;
      const cWidth = 140;
      const puzzleY = Math.floor(this.scale.height / 2);
      // group remaining tiles by type
      const vs = (this.poolSprites || []).filter(g => g.getData && g.getData('type') === 'V');
      const ds = (this.poolSprites || []).filter(g => g.getData && g.getData('type') === 'D');
      const js = (this.poolSprites || []).filter(g => g.getData && g.getData('type') === 'J');
      // plan layout: V block (all remaining V), D1 (first D if exists), J block 1 (up to 5), C1, D2 (next D if exists), J block 2 (up to 5), C2
      const vCount = vs.length;
      const dCount = ds.length;
      const jCount1 = Math.min(5, js.length);
      const jCount2 = Math.max(0, js.length - jCount1);
      const vWidth = vCount * boxSize + Math.max(0, vCount - 1) * tileGap;
      const dSingles = Math.min(2, dCount);
      const dWidth = dSingles * boxSize + Math.max(0, dSingles - 1) * tileGap;
      const jWidth = (jCount1 + jCount2) * boxSize + Math.max(0, (jCount1 + jCount2) - 1) * tileGap;
      const totalWidth = vWidth + dWidth + jWidth + groupGap * 2 + cWidth * 2;
      const availableWidth = Math.max(0, this.scale.width - 2 * margin);
      const startX = margin + Math.floor((availableWidth - totalWidth) / 2) + Math.floor(boxSize/2);

      let cursorX = startX;
      // place Vs
      for (let i=0;i<vs.length;i++) {
        const g = vs[i];
        const x = cursorX;
        const y = puzzleY;
        this.tweens.add({ targets: g, x, y, duration: 300, ease: 'Cubic' });
        g.setData('homeX', x); g.setData('homeY', y);
        cursorX += boxSize + tileGap;
      }
      // D1
      cursorX += groupGap - tileGap;
      if (ds.length >= 1) {
        const g = ds[0];
        const x = cursorX; const y = puzzleY;
        this.tweens.add({ targets: g, x, y, duration: 300, ease: 'Cubic' });
        g.setData('homeX', x); g.setData('homeY', y);
        cursorX += boxSize + tileGap;
      }
      // J block 1
      cursorX += groupGap - tileGap;
      for (let i=0;i<jCount1;i++) {
        const g = js[i];
        const x = cursorX; const y = puzzleY;
        this.tweens.add({ targets: g, x, y, duration: 300, ease: 'Cubic' });
        g.setData('homeX', x); g.setData('homeY', y);
        cursorX += boxSize + tileGap;
      }
      // C1 position
      if (this.constantGraphics && this.constantGraphics.length >= 2) {
        const c1 = this.constantGraphics[0];
        const c1Text = this.constantGraphics[1];
        const c1x = cursorX + cWidth/2;
        try { c1.clear(); c1.fillStyle(0xfff382, 1); c1.fillRoundedRect(c1x - cWidth/2, puzzleY - boxSize/2, cWidth, boxSize, 8); } catch(e){}
        try { c1Text.setPosition(c1x, puzzleY); } catch(e){}
        cursorX += cWidth + tileGap;
      }
      // D2
      if (ds.length >= 2) {
        const g = ds[1];
        const x = cursorX; const y = puzzleY;
        this.tweens.add({ targets: g, x, y, duration: 300, ease: 'Cubic' });
        g.setData('homeX', x); g.setData('homeY', y);
        cursorX += boxSize + tileGap;
      }
      // J block 2
      cursorX += groupGap - tileGap;
      for (let i= jCount1; i < jCount1 + jCount2; i++) {
        const g = js[i];
        const x = cursorX; const y = puzzleY;
        this.tweens.add({ targets: g, x, y, duration: 300, ease: 'Cubic' });
        g.setData('homeX', x); g.setData('homeY', y);
        cursorX += boxSize + tileGap;
      }
      // C2 position
      if (this.constantGraphics && this.constantGraphics.length >= 4) {
        const c2 = this.constantGraphics[2];
        const c2Text = this.constantGraphics[3];
        const c2x = cursorX + cWidth/2;
        try { c2.clear(); c2.fillStyle(0xfff382, 1); c2.fillRoundedRect(c2x - cWidth/2, puzzleY - boxSize/2, cWidth, boxSize, 8); } catch(e){}
        try { c2Text.setPosition(c2x, puzzleY); } catch(e){}
        cursorX += cWidth + tileGap;
      }
    } catch (e) { console.warn('rearrangePool failed', e); }
  }

  // Remove a sprite from its belt array
  removeFromPools(gameObject) {
    if (!gameObject || !this.poolSprites) return;
    // support both flat-array poolSprites and per-belt object
    if (Array.isArray(this.poolSprites)) {
      Phaser.Utils.Array.Remove(this.poolSprites, gameObject);
      return;
    }
    const t = gameObject.getData('type');
    if (!t) return;
    const arr = this.poolSprites[t];
    if (!arr) return;
    Phaser.Utils.Array.Remove(arr, gameObject);
  }

  // Slot outline helpers
  resetAllSlotOutlines() {
    if (!this.dropSlots) return;
    this.dropSlots.forEach(s => { if (s.rect) { s.rect.setStrokeStyle(2, this.PALETTE.neutralStroke); s.rect.setAlpha(0.45); } });
  }

  highlightSlotWithType(slot, type) {
    if (!slot || !slot.rect) return;
    const highlight = type === 'V' ? this.PALETTE.V : (type === 'D' ? this.PALETTE.D : this.PALETTE.J);
    slot.rect.setStrokeStyle(4, highlight);
    slot.rect.setAlpha(0.9);
  }

  // Update the top UI: three recipe boxes and the target image next to them
  updateCurrentTarget() {
    if (!this.pathogens || this.pathogens.length === 0) return;
    const next = this.pathogens.findIndex(p => !p.done);
    if (next === -1) {
      this.currentTargetIndex = -1;
      // clear UI
      if (this.targetGraphic) this.targetGraphic.clear();
      if (this.targetImage) { try { this.targetImage.destroy(); } catch(e){} this.targetImage = null; }
      if (this.topRecipeBoxes) this.topRecipeBoxes.forEach(s => { s.text.setText(''); s.rect.setFillStyle(0x06121a); });
      return;
    }
    this.currentTargetIndex = next;
    const p = this.pathogens[next];

    // Determine image key; we mapped filenames to keys when loading
    let chosenKey = null;
    if (this.pathogenImageKeys && this.pathogenImageKeys[next]) {
      const entry = this.pathogenImageKeys[next];
      if (entry && entry.key && this.textures && this.textures.exists && this.textures.exists(entry.key)) {
        chosenKey = entry.key;
      }
    }

    // Clear previous visuals
    if (this.targetGraphic) this.targetGraphic.clear();
    if (this.targetImage) { try { this.targetImage.destroy(); } catch(e){} this.targetImage = null; }

    if (chosenKey && this.targetContainer) {
      // Add image and scale to fit
      this.targetImage = this.add.image(0, 0, chosenKey).setDepth(13);
      const maxW = 120, maxH = 120;
      try {
        const tex = this.textures.get(chosenKey).getSourceImage();
        const iw = tex.width || maxW, ih = tex.height || maxH;
        const scale = Math.min(maxW / iw, maxH / ih);
        this.targetImage.setScale(scale);
      } catch (e) {
        this.targetImage.setDisplaySize(maxW, maxH);
      }
      this.targetContainer.add(this.targetImage);
    } else if (this.targetGraphic) {
      // Fallback: draw a simple antibody-like icon
      const colors = [0x7c3aed,0xf97316,0x10b981,0x06b6d4,0xf43f5e,0xf59e0b,0x60a5fa,0xc084fc,0xf472b6,0x34d399];
      const col = colors[next % colors.length];
      this.targetGraphic.fillStyle(col, 1);
      this.targetGraphic.fillCircle(-40, -8, 18);
      this.targetGraphic.fillCircle(40, -8, 18);
      this.targetGraphic.fillStyle(0xffffff, 1);
      this.targetGraphic.fillRect(-6, 6, 12, 36);
      this.targetGraphic.lineStyle(6, col, 1);
      this.targetGraphic.beginPath();
      this.targetGraphic.moveTo(-22, 6);
      this.targetGraphic.lineTo(-46, 26);
      this.targetGraphic.moveTo(22, 6);
      this.targetGraphic.lineTo(46, 26);
      this.targetGraphic.strokePath();
    }

    // Update the three recipe boxes with the target sequence
    if (this.topRecipeBoxes && Array.isArray(this.topRecipeBoxes)) {
      const parts = (p.recipe || '').split('-');
      for (let i = 0; i < 3; i++) {
        const seg = parts[i] || '';
        const box = this.topRecipeBoxes[i];
        if (!box) continue;
        box.text.setText(seg);
        const fill = seg.startsWith('V') ? this.PALETTE.V : (seg.startsWith('D') ? this.PALETTE.D : this.PALETTE.J);
        box.rect.setFillStyle(fill);
      }
    }
  }

  resetRound() {
    this.dropSlots.forEach(s => { if (s.occupied) { s.occupied.destroy(); s.occupied = null; } });
    this.resetAllSlotOutlines();
    if (this.poolSprites) {
      if (Array.isArray(this.poolSprites)) { this.poolSprites.forEach(s => { try { s.destroy(); } catch(e){} }); }
      else { ['V','D','J'].forEach(k => { if (this.poolSprites[k]) { this.poolSprites[k].forEach(s => { try { s.destroy(); } catch(e){} }); this.poolSprites[k] = []; } }); }
    }
    // destroy constant graphics (C1/C2 blocks) if any
    if (this.constantGraphics && Array.isArray(this.constantGraphics)) { this.constantGraphics.forEach(cg => { try { cg.destroy(); } catch(e){} }); this.constantGraphics = []; }
    this.makeRound();

    // --- Background music: play quietly after the first user gesture (browser autoplay rules) ---
    try {
      // sound was queued in preload
      this.bgm = this.sound.add('bgm', { loop: true, volume: 0.14 });
    } catch (e) {
      console.warn('BGM not available:', e);
      this.bgm = null;
    }

    // Start/resume audio on first pointerdown to satisfy autoplay policies
    this.input.once('pointerdown', () => {
      try {
        if (this.sound && this.sound.context && this.sound.context.state === 'suspended') {
          this.sound.context.resume();
        }
      } catch (e) {}
      try {
        // Only start playing bgm if audio is not muted
        if (this.bgm && !this.bgm.isPlaying && !this.sound.mute) this.bgm.play();
      } catch (e) { console.warn('Could not play bgm:', e); }
    });

    // --- Mute toggle UI & persistence ---
    try {
      const mutedKey = 'vdj_muted';
      const saved = localStorage.getItem(mutedKey);
      const muted = saved === '1' || saved === 'true';
      try { this.sound.mute = muted; } catch (e) {}

      // create a small mute/unmute button under the timer
      const muteX = 18;
      const muteY = 78;
      this.muteBtn = this.add.text(muteX, muteY, this.sound.mute ? 'ðŸ”‡' : 'ðŸ”Š', { fontSize: '22px', color: '#e6eef8', backgroundColor:'#1e293b', padding:{ x:8, y:6 } }).setDepth(20).setInteractive({ useHandCursor: true });
      this.muteBtn.on('pointerdown', () => {
        try {
          this.sound.mute = !this.sound.mute;
          this.muteBtn.setText(this.sound.mute ? 'ðŸ”‡' : 'ðŸ”Š');
          try { localStorage.setItem(mutedKey, this.sound.mute ? '1' : '0'); } catch (e) {}
          // control bgm playback to avoid starting audio when muted
          if (this.bgm) {
            try {
              if (this.sound.mute) {
                if (this.bgm.isPlaying) this.bgm.pause();
              } else {
                if (!this.bgm.isPlaying) this.bgm.play();
              }
            } catch (e) { console.warn('Error controlling bgm on mute toggle', e); }
          }
        } catch (e) { console.warn('Mute toggle failed', e); }
      });
      // Create a "Remove Selected" button next to the mute button
      const removeX = 18 + 72; // offset to the right of mute
      const removeY = 78;
      this.removeBtn = this.add.text(removeX, removeY, 'ðŸ—‘ï¸ Remove Selected', { fontSize: '16px', color: '#e6eef8', backgroundColor:'#7c2d12', padding:{ x:8, y:6 } }).setDepth(20).setInteractive({ useHandCursor: true });
      this.removeBtn.on('pointerdown', () => {
        try {
          const toRemove = (this.poolSprites || []).filter(g => g.getData && g.getData('selected'));
          if (!toRemove.length) { this.feedback.setText('No tiles selected to remove.'); return; }
          toRemove.forEach(g => {
            try {
              // remove from pool array
              this.removeFromPools(g);
              // destroy the game object
              if (g.input) g.input.enabled = false;
              g.destroy();
            } catch (e) { console.warn('Failed to remove selected tile', e); }
          });
          // reflow remaining tiles
          this.rearrangePool();
          this.feedback.setText(`Removed ${toRemove.length} selected tile(s).`);
        } catch (e) { console.warn('Remove selected failed', e); }
      });
    } catch (e) { console.warn('Mute UI setup failed', e); }
  }

  endGame(won) {
    // Stop timer
    if (this.timerEvent) { this.timerEvent.remove(false); }
    // stop background music if playing
    try { if (this.bgm && this.bgm.isPlaying) this.bgm.stop(); } catch (e) {}
    // Disable input
    this.input.enabled = false;
    const w = this.scale.width;
    const h = this.scale.height;
    const msg = won ? 'All pathogens neutralized! You win!' : 'Time is up â€” game over';
    const color = won ? '#10b981' : '#ef4444';
    // Show a simple central message, then prompt for username/leaderboard
    const box = this.add.rectangle(w/2, h/2, Math.min(800, w-80), 160, 0x071227).setStrokeStyle(2, 0x17375f).setDepth(50);
    this.add.text(w/2, h/2-12, msg, { fontSize: '26px', color }).setOrigin(0.5).setDepth(51);
    this.add.text(w/2, h/2+26, `Score: ${this.score}`, { fontSize: '18px', color: '#e6eef8' }).setOrigin(0.5).setDepth(51);

    // Prompt for username and show leaderboard (DOM overlay)
    this.time.delayedCall(300, () => { this.showLeaderboardPrompt(won); });
  }

  // Leaderboard helpers: use localStorage to persist top scores
  showLeaderboardPrompt(won) {
    // ensure only one overlay
    if (this._vdjOverlay) { try { document.body.removeChild(this._vdjOverlay); } catch(e) {} this._vdjOverlay = null; }
    // create overlay
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.width = '100%'; overlay.style.height = '100%';
    overlay.style.display = 'flex'; overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center';
    overlay.style.background = 'rgba(2,6,23,0.72)'; overlay.style.zIndex = '9999';

    const panel = document.createElement('div');
    panel.style.minWidth = '360px'; panel.style.maxWidth = '860px'; panel.style.padding = '18px';
    panel.style.background = '#071227'; panel.style.border = '2px solid #17375f'; panel.style.borderRadius = '10px';
    panel.style.color = '#e6eef8'; panel.style.fontFamily = 'Arial, sans-serif'; panel.style.textAlign = 'center';

    const title = document.createElement('div');
    title.style.fontSize = '20px'; title.style.marginBottom = '8px';
    title.textContent = won ? 'Victory! Submit your name for the leaderboard' : 'Game Over â€” Submit your name for the leaderboard';
    panel.appendChild(title);

    const scoreLine = document.createElement('div');
    scoreLine.style.marginBottom = '12px';
    scoreLine.textContent = `Score: ${this.score}`;
    panel.appendChild(scoreLine);

    const input = document.createElement('input');
    input.type = 'text'; input.placeholder = 'Enter username';
    input.style.padding = '8px'; input.style.width = '70%'; input.style.marginBottom = '12px'; input.style.borderRadius = '6px';
    panel.appendChild(input);

    const submit = document.createElement('button');
    submit.textContent = 'Submit';
    submit.style.margin = '0 8px'; submit.style.padding = '8px 12px'; submit.style.borderRadius = '6px';
    submit.style.cursor = 'pointer';
    panel.appendChild(submit);

    const skip = document.createElement('button');
    skip.textContent = 'Skip';
    skip.style.margin = '0 8px'; skip.style.padding = '8px 12px'; skip.style.borderRadius = '6px';
    skip.style.cursor = 'pointer';
    panel.appendChild(skip);

    overlay.appendChild(panel);
    document.body.appendChild(overlay);
    this._vdjOverlay = overlay;

    const finalize = (name) => {
      const entry = { name: name || 'Anonymous', score: this.score, timeLeft: this.timeLeft, date: (new Date()).toISOString() };
      this.saveLeaderboardEntry(entry);
      this.showLeaderboard();
    };

    submit.addEventListener('click', () => { finalize(input.value && input.value.trim()); });
    input.addEventListener('keydown', (e) => { if (e.key === 'Enter') finalize(input.value && input.value.trim()); });
    skip.addEventListener('click', () => { finalize('Anonymous'); });
    input.focus();
  }

  saveLeaderboardEntry(entry) {
    try {
      const key = 'vdj_leaderboard';
      const raw = localStorage.getItem(key);
      const list = raw ? JSON.parse(raw) : [];
      list.push(entry);
      // sort by score desc, then timeLeft desc, then recent date
      list.sort((a,b) => { if (b.score !== a.score) return b.score - a.score; if ((b.timeLeft||0) !== (a.timeLeft||0)) return (b.timeLeft||0) - (a.timeLeft||0); return new Date(b.date) - new Date(a.date); });
      // keep top 10
      const trimmed = list.slice(0, 10);
      localStorage.setItem(key, JSON.stringify(trimmed));
    } catch (e) { console.warn('Could not save leaderboard', e); }
  }

  showLeaderboard() {
    // remove previous overlay contents
    if (this._vdjOverlay) {
      try { document.body.removeChild(this._vdjOverlay); } catch(e) {}
      this._vdjOverlay = null;
    }
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed'; overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.width = '100%'; overlay.style.height = '100%';
    overlay.style.display = 'flex'; overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center';
    overlay.style.background = 'rgba(2,6,23,0.72)'; overlay.style.zIndex = '9999';

    const panel = document.createElement('div');
    panel.style.minWidth = '360px'; panel.style.maxWidth = '860px'; panel.style.padding = '18px';
    panel.style.background = '#071227'; panel.style.border = '2px solid #17375f'; panel.style.borderRadius = '10px';
    panel.style.color = '#e6eef8'; panel.style.fontFamily = 'Arial, sans-serif';

    const title = document.createElement('div'); title.style.fontSize = '20px'; title.style.marginBottom = '8px'; title.textContent = 'Leaderboard'; panel.appendChild(title);

    const key = 'vdj_leaderboard';
    const raw = localStorage.getItem(key);
    const list = raw ? JSON.parse(raw) : [];

    const listEl = document.createElement('div'); listEl.style.textAlign = 'left'; listEl.style.marginBottom = '12px';
    if (list.length === 0) listEl.textContent = 'No scores yet.';
    else {
      list.forEach((e,i) => {
        const row = document.createElement('div');
        row.style.padding = '6px 0';
        row.textContent = `${i+1}. ${e.name} â€” Score: ${e.score} â€” Time left: ${e.timeLeft || 0}s`;
        listEl.appendChild(row);
      });
    }
    panel.appendChild(listEl);

    const tryAgain = document.createElement('button'); tryAgain.textContent = 'Try Again';
    tryAgain.style.padding = '10px 14px'; tryAgain.style.borderRadius = '6px'; tryAgain.style.cursor = 'pointer';
    panel.appendChild(tryAgain);

    overlay.appendChild(panel); document.body.appendChild(overlay); this._vdjOverlay = overlay;

    tryAgain.addEventListener('click', () => {
      // remove overlay and restart the scene
      try { document.body.removeChild(this._vdjOverlay); } catch(e) {}
      this._vdjOverlay = null;
      this.scene.restart();
    });
  }
}

// Add error event listener to window
window.addEventListener('error', function(event) {
    console.error('Global error:', event.error);
});

const config = {
  type: Phaser.AUTO,
  parent: 'game-container',
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: window.innerWidth, height: window.innerHeight },
  backgroundColor: '#071227',
  scene: [ GameScene ],
  physics: {
    default: 'arcade',
    arcade: {
      debug: true
    }
  },
  input: {
    activePointers: 1,
    dragTimeThreshold: 50,
    draggable: true
  }
};

try {
  console.log('Initializing game...');
  const game = new Phaser.Game(config);
  console.log('Game initialized successfully');
} catch (error) {
  console.error('Error initializing game:', error);
}
</script>
</body>
</html>
